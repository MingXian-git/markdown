---
typora-root-url: ..\..\Software\Typora\typora-image
---

## 一、注解

### 1.@Transactional

https://www.jianshu.com/p/907a895587bf

声明式事务，在业务层使用@Transactional 配置声明式事务管理

#### 1.1 @Transactional 的可用参数

1. rollbackFor

   该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。

   `@Transactional(rollbackFor=RuntimeException.class)`

2. 



## 二、Spring Framework之事务管理 

https://www.cnblogs.com/yubaolee/p/10398633.html

### 1.事务隔离级别、脏读、不可重复读、幻读 

#### 1.1.脏读

A事务执行过程中，B事务读取了A事务的修改。但是由于某些原因，A事务可能没有完成提交，发生RollBack了操作，则B事务所读取的数据就会是不正确的。这个未提交数据就是脏读（Dirty Read）。

#### 1.2.不可重复读

B事务读取了两次数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的数据不一样。B事务这种读取的结果，即为不可重复读（Nonrepeatable Read）。

> 特殊情况：**第二类丢失更新**
>
> 两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失
>
> ![微信截图_20190223114546](https://img2018.cnblogs.com/blog/42655/201902/42655-20190223114714574-1005656824.png)

#### 1.3.幻读

B事务读取了两次数据，在这两次的读取过程中A事务添加了数据，B事务的这两次读取出来的集合不一样。

> 这个流程看起来和不可重复读差不多，但幻读强调的集合的增减，而不是单独一条数据的修改。

#### 1.4.数据库隔离级别

+ **读未提交（Read Uncommitted）**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别是最低的隔离级别，虽然拥有超高的并发处理能力及很低的系统开销，但很少用于实际应用。因为采用这种隔离级别只能防止第一类更新丢失问题，不能解决脏读，不可重复读及幻读问题。

+ **读已提交（Read Committed）**

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别可以防止脏读问题，但会出现不可重复读及幻读问题。

+ **可重复读（Repeatable Read）**

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这种隔离级别可以防止除幻读外的其他问题。

+ **可串行化（Serializable）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读、第二类更新丢失问题。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常数据库不会用这个隔离级别，我们需要其他的机制来解决这些问题:乐观锁和悲观锁。

## 三、`dto.getStationIds().stream().map(t -> {//todo});`

`dto.getStationIds() `  得到一个 id 数组。map 方法用于映射每个元素到对应的结果。`map(t -> {})` map将 id 数组一个一个拿出来赋给t，进行操作。



## 四、`@Valid` 修饰变量，`@NotBlank` 修饰变量对象类中的属性

``` java

@RestController
@RequestMapping("/user")
public class UserController {
    @PostMapping
    public User create (@Valid @RequestBody User user) {
        System.out.println(user.getId());
        System.out.println(user.getUsername());
        System.out.println(user.getPassword());
        user.setId("1");
        return user;
    }
} 
```



``` java
public class User {
    private String id;  
 
    @NotBlank(message = "密码不能为空")
    private String password;
}

```

`@NotBlank`  注解所指的 password 字段，表示验证密码不能为空，如果为空的话，上面 Controller 中的 create 方法会将message 中的"密码不能为空"返回。



## 五、`FinalPageVO` `CompletableFuture`